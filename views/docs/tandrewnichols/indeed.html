{%= extends 'layout.html' %}

{%= block content %}
  <div class="row">
    <div class="col-xs-12">
      <div class="row">
        <div class="mlm plm col-xs-2">
          <div class="list-group fixed-sidebar-top" data-spy="affix" data-offset-top="1">
            <a id="github-{{= module.name }}" ng-init="mixpanel.track_links('#github-{{= module.name }}', 'Click', { target: 'github', module: '{{= module.name }}', action: 'view' })" href="https://github.com/{{= author }}/{{= module.name }}" target="_blank" class="list-group-item"><span class="fa fa-github"></span><span class="mls">View it on Github</span></a>
            <a id="fork-{{= module.name }}" ng-init="mixpanel.track_links('#fork-{{= module.name }}', 'Click', { target: 'github', module: '{{= module.name }}', action: 'fork' })" href="https://github.com/{{= author }}/{{= module.name }}/fork" target="_blank" class="list-group-item"><span class="fa fa-code-fork"></span><span class="mls">Fork it</span></a>
            <a id="npm-{{= module.name }}" ng-init="mixpanel.track_links('#npm-{{= module.name }}', 'Click', { target: 'npm', module: '{{= module.name }}', action: 'view' })" href="https://www.npmjs.org/package/{{= module.name }}" target="_blank" class="list-group-item"><span class="ta ta-npm"></span><span class="mls">View it on npm</span></a>
            <a href="http://twitter.com/share" tweet='Check out "{{= module.name }}" at' tweet-tags="nodejs" tweet-topic="{{= module.name }}" class="list-group-item"><span class="fa fa-twitter"></span><span class="mls">Tweet it</span></a>
            {%= if module.coverage %}
              <a href="/coverage/{{= module.name }}" ng-init="mixpanel.track_links('#btn-coverage-{{= module.name }}', 'Click', { target: 'coverage', module: '{{= module.name }}', action: 'view' })" class="list-group-item"><span class="fa fa-code"></span><span class="mls">View test coverage</span></a>
            {%= endif %}
          </div>
          <div class="list-group text-center fixed-sidebar" data-spy="affix" data-offset-top="1" style="font-size: 20pt;">
            <a id="btn-github-{{= module.name }}" ng-init="mixpanel.track_links('#btn-github-{{= module.name }}', 'Click', { target: 'github', page: '{{= module.name }}' })" href="https://github.com/{{= author }}/{{= module.name }}" target="_blank" class="list-group-item" title="View it on Github"><span class="fa fa-github"></span></a>
            <a id="btn-fork-{{= module.name }}" ng-init="mixpanel.track_links('#btn-fork-{{= module.name }}', 'Click', { target: 'github', page: 'fork {{= module.name }}' })" href="https://github.com/{{= author }}/{{= module.name }}/fork" target="_blank" class="list-group-item" title="Fork it"><span class="fa fa-code-fork"></span></a>
            <a id="btn-npm-{{= module.name }}" ng-init="mixpanel.track_links('#btn-npm-{{= module.name }}', 'Click', { target: 'npm', page: '{{= module.name }}' })" href="https://www.npmjs.org/package/{{= module.name }}" target="_blank" class="list-group-item" title="View it on npm"><span class="ta ta-npm"></span></a>
            <a href="http://twitter.com/share" tweet='Check out "{{= module.name }}" at' tweet-tags="nodejs" tweet-topic="{{= module.name }}" class="list-group-item" title="Tweet it"><span class="fa fa-twitter"></span></a>
            {%= if module.coverage %}
              <a id="btn-coverage-{{= module.name }}" ng-init="mixpanel.track_links('#btn-coverage-{{= module.name }}', 'Click', { target: 'coverage', page: '{{= module.name }}' })" href="/coverage/{{= module.name }}" class="list-group-item" title="View test coverage"><span class="fa fa-code"></span></a>
            {%= endif %}
          </div>
        </div>
        <div class="col-xs-9">
          <p><a href="https://travis-ci.org/tandrewnichols/indeed"><img src="https://travis-ci.org/tandrewnichols/indeed.png" alt="Build Status"></a> <a href="https://npmjs.org/package/indeed"><img src="http://img.shields.io/npm/dm/indeed.svg" alt="downloads"></a> <a href="https://npmjs.org/package/indeed"><img src="http://img.shields.io/npm/v/indeed.svg" alt="npm"></a> <a href="https://codeclimate.com/github/tandrewnichols/indeed"><img src="https://codeclimate.com/github/tandrewnichols/indeed/badges/gpa.svg" alt="Code Climate"></a></p>
<h1 id="indeed">Indeed</h1>
<p>Boolean helpers for node.js</p>
<h2 id="why-bother-">Why Bother?</h2>
<p>Simple booleans are efficient and not that hard to use in javascript, so what&apos;s the value of a DDL for booleans? Mainly, I just find booleans one of those things that, if I think too hard about them, then I get lost. The project was born when I had</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (!oneThing &amp;&amp; anotherThing) {
  // . . .
}</code></pre>
<p>but then realized I actually needed the negative of <code ng-non-bindable="">anotherThing</code>. So I changed it to</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (!oneThing &amp;&amp; !anotherThing) {
  // . . .
}</code></pre>
<p>at which point, I started wondering if that was the same as</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (!(oneThing &amp;&amp; anotherThing)) {
  // . . .
}</code></pre>
<p>And then I thought, what I really want is to say</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (neither(oneThing).nor(anotherThing)) {
  // do something
}</code></pre>
<p>and thus the module &quot;neither&quot; was born. And then I later changed it to &quot;indeed&quot;, which was more globally usable as a boolean helper. A bit of an anti-climatic ending, really. At any rate, this library is just a set of boolean helpers to put <code ng-non-bindable="">if</code> statements into English-like syntax. Note that I used to be an English teacher and thus, that syntax is extremely opinionated and grammatically correct. Grammar is your friend.</p>
<p><img src="http://50gooddeeds.files.wordpress.com/2012/06/howcangooglesearch.jpg" alt="Grammar Matters"></p>
<p>Ahem . . . now on with the API.</p>
<h2 id="installation">Installation</h2>
<pre><code class="lang-bash" ng-non-bindable="">npm install indeed --save</code></pre>
<p>then</p>
<pre><code class="lang-javascript" ng-non-bindable="">var helpers = require(&apos;indeed&apos;);</code></pre>
<p>or</p>
<pre><code class="lang-javascript" ng-non-bindable="">// Set up global methods.
// Mainly useful because I don&apos;t like having to say &quot;if (helpers.indeed(a)...&quot;
require(&apos;indeed&apos;)();</code></pre>
<h2 id="usage">Usage</h2>
<p>When you <code ng-non-bindable="">require(&apos;indeed&apos;)</code>, you&apos;ll get an object with methods that begin boolean chains: <code ng-non-bindable="">indeed</code>, <code ng-non-bindable="">either</code>, <code ng-non-bindable="">neither</code>, <code ng-non-bindable="">both</code>, <code ng-non-bindable="">allOf</code>, <code ng-non-bindable="">oneOf</code>, <code ng-non-bindable="">noneOf</code>, <code ng-non-bindable="">anyOf</code>, <code ng-non-bindable="">nOf</code>, and <code ng-non-bindable="">expect</code>. These function are roughly the same - they allow you to assess conditions using natural language. These conditions are processed first in first out, so they can behave slightly differently than normal boolean logic. For example: <code ng-non-bindable="">if (a &amp;&amp; b || c)</code> becomes <code ng-non-bindable="">if (indeed(a).and(b).or(c))</code> as you might expect. However, <code ng-non-bindable="">if (indeed(a).or(b).and(c))</code> actually means <code ng-non-bindable="">if( (a || b) &amp;&amp; c)</code> because of how order of operations works. See <a href="#grouping">Grouping</a> below for more information.</p>
<h4 id="indeed">Indeed</h4>
<p>Begins a generic chain.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code>, <code ng-non-bindable="">andNot</code>, <code ng-non-bindable="">or</code>, <code ng-non-bindable="">orNot</code>, <code ng-non-bindable="">butNot</code>, and <code ng-non-bindable="">xor</code><br>
Chain limit: none</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(a).and(b).butNot(c).or(d).test())</code></pre>
<p>Chaining is off by default with <code ng-non-bindable="">indeed</code>, so that you can make simple comparisons:</p>
<pre><code class="lang-javascript" ng-non-bindable="">// returns &apos;true&apos;
indeed(a).is.true()

// returns &apos;indeed&apos; so that you can assert more conditions
indeed.chain(a).is.true() // .and(b).is.false().test()</code></pre>
<p>When chaining, use <code ng-non-bindable="">.test()</code>, <code ng-non-bindable="">.val()</code>, or <code ng-non-bindable="">.eval()</code> to terminate the chain and evaluate the total result of the expression. Non-chaining is optimized for <a href="#matching">comparisons</a>, so <code ng-non-bindable="">indeed(a).is.defined()</code> will return <code ng-non-bindable="">true</code> or <code ng-non-bindable="">false</code> whereas <code ng-non-bindable="">indeed(a)</code> by itself, will not. To assert on the definedness of a single thing, 1) chain: <code ng-non-bindable="">if (indeed.chain(a).test())</code>, 2) use <code ng-non-bindable="">defined()</code>: <code ng-non-bindable="">if (indeed(a).is.defined())</code>, 3) use regular booleans: <code ng-non-bindable="">if (a)</code>. Calling one of the chain methods without calling a comparison will automatically turn on chaining, so that you can say <code ng-non-bindable="">if (indeed(a).and(b).and(c).test())</code> rather than <code ng-non-bindable="">if (indeed.chain(a).and(b).and(c).test())</code>.</p>
<p><code ng-non-bindable="">indeed</code> is also equipped with some negation tools: <code ng-non-bindable="">not</code> and <code ng-non-bindable="">Not</code>. <code ng-non-bindable="">not</code> simply negates the first condition:</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed.not(a).and(b).test())</code></pre>
<p>is equivalent to</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (!a &amp;&amp; b)</code></pre>
<p><code ng-non-bindable="">Not</code> negates the result of the chain, so</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed.Not(a).and(b).test())</code></pre>
<p>is equivalent to</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (!(a &amp;&amp; b))</code></pre>
<p>These too can be chained:</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed.not.chain(a).and(b).test())
if (indeed.Not.chain(a).or(b).test())</code></pre>
<h4 id="either">Either</h4>
<p>Begins a chain where one of two conditions (or both) should be true.</p>
<p>Chainable methods: <code ng-non-bindable="">or</code><br>
Chain limit: 1<br>
Optimized for: existence checks</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (either(a).or(b))
if (either.chain(a).is.null().or(b).is.defined().test())</code></pre>
<h4 id="neither">Neither</h4>
<p>Begins a chain where both conditions should be false. </p>
<p>Chainable methods: <code ng-non-bindable="">nor</code><br>
Chain limit: 1<br>
Optimized for: existence checks</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (neither(a).nor(b))
if (neither.chain(a).equals(&apos;foo&apos;).nor(b).is.a(&apos;date&apos;).test())</code></pre>
<h4 id="both">Both</h4>
<p>Begins a chain where both conditions should be true.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code><br>
Chain limit: 1<br>
Optimized for: existence checks</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (both(a).and(b))
if (both.chain(a).is.false().and(b).contains(&apos;bar&apos;).test())</code></pre>
<h4 id="allof">AllOf</h4>
<p>Begins a chain where all conditions should be true. Incidentally, it only makes sense to use this with more than two conditions. With two conditions only, use <code ng-non-bindable="">both</code>.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code><br>
Chain limit: none<br>
Chaining is on by default and cannot be turned off since any number of <code ng-non-bindable="">and</code>&apos;s can be used</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (allOf(a).and(b).and(c).test())</code></pre>
<h4 id="anyof">AnyOf</h4>
<p>Begins a chain where at least one condition should be true.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code><br>
Chain limit: none<br>
Chaining is on by default and cannot be turned off since any number of <code ng-non-bindable="">and</code>&apos;s can be used</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (anyOf(a).and(b).and(c).test())</code></pre>
<h4 id="oneof">OneOf</h4>
<p>Begins a chain where exactly one condition should be true.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code><br>
Chain limit: none<br>
Chaining is on by default and cannot be turned off since any number of <code ng-non-bindable="">and</code>&apos;s can be used</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (oneOf(a).and(b).and(c).test())</code></pre>
<h4 id="noneof">NoneOf</h4>
<p>Begins a chain where all of the conditions should be false. With only two conditions, use <code ng-non-bindable="">neither</code> instead.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code><br>
Chain limit: none<br>
Chaining is on by default and cannot be turned off since any number of <code ng-non-bindable="">and</code>&apos;s can be used</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (noneOf(a).and(b).and(c).test())</code></pre>
<h4 id="nof">NOf</h4>
<p><code ng-non-bindable="">nOf</code> is the only helper that deviates from the standard structure. It accepts a number, and then any number of conditions, of which <em>exactly</em> that number must be true.</p>
<p>Chainable methods: <code ng-non-bindable="">and</code><br>
Chain limit: none<br>
Chaining is on by default and cannot be turned off since any number of <code ng-non-bindable="">and</code>&apos;s can be used</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (n(2).of(a).and(b).and(c).test())</code></pre>
<h4 id="expect">Expect</h4>
<p>Expect is identical to indeed and has all it&apos;s additional properties. It adds only a couple things: a <code ng-non-bindable="">throws</code> comparison function (detailed below) for asserting that a function throws an exception, a <code ng-non-bindable="">with</code> function for passing args to a function that should throw, and <code ng-non-bindable="">assert</code>, which is the same as <code ng-non-bindable="">test</code> but sounds more test-ish.</p>
<h2 id="grouping">Grouping</h2>
<p>You can create groups of chains, which are also evaluated left to right, using the properties <code ng-non-bindable="">And</code>, <code ng-non-bindable="">But</code>, <code ng-non-bindable="">Or</code>, and <code ng-non-bindable="">Xor</code>. They do what you would expect:</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(a).or(b).And.indeed(c).test())

if (indeed(a).and(b).Or.indeed(c).test())

if (indeed(a).and(b).Xor.indeed(c).test())

if (indeed(a).and(b).But.not.also(c).test())</code></pre>
<p>The first example evaluates <code ng-non-bindable="">a || b</code> first and then the result of that with <code ng-non-bindable="">&amp;&amp; c</code>. <code ng-non-bindable="">But</code> is an alias to <code ng-non-bindable="">And</code> because sometimes it feels more natural to say &quot;but&quot; than &quot;and.&quot; <code ng-non-bindable="">indeed</code> also has several aliases that can be used after joins depending on what you want to say next:</p>
<pre><code class="lang-javascript" ng-non-bindable="">// just like indeed
if (indeed(a).or(b).And.also(c).test())

// also just like indeed
if (indeed(a).and(b).Or.else(c).test())

// just like indeed, but negated
if (indeed(a).and(b).But.not.also(c).test())

// just like indeed, but negates the entire next group
if (indeed(a).and(b).But.Not.also(c).or(d).test())</code></pre>
<p>Additionally, all of the entry points are chainable after a Grouping property:</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(a).or(b).But.neither(c).nor(d).test())</code></pre>
<h2 id="matching">Matching</h2>
<p>All the examples so far have been simple checks for definedness (for simplicity), but <code ng-non-bindable="">indeed</code> has a wide variety of comparison functions as well. All of the chain starters also have the chainable properties <code ng-non-bindable="">does</code>, <code ng-non-bindable="">should</code>, <code ng-non-bindable="">has</code>, <code ng-non-bindable="">have</code>, <code ng-non-bindable="">is</code>, <code ng-non-bindable="">to</code>, <code ng-non-bindable="">be</code>, <code ng-non-bindable="">been</code>, <code ng-non-bindable="">deep</code>, <code ng-non-bindable="">deeply</code>, <code ng-non-bindable="">not</code>, <code ng-non-bindable="">Not</code>, <code ng-non-bindable="">noCase</code>, and <code ng-non-bindable="">caseless</code>. In addition, <code ng-non-bindable="">indeed</code> and <code ng-non-bindable="">expect</code> have <code ng-non-bindable="">andDoes</code>, <code ng-non-bindable="">andShould</code>, <code ng-non-bindable="">andHas</code>, <code ng-non-bindable="">andHave</code>, <code ng-non-bindable="">andIs</code>, <code ng-non-bindable="">andTo</code>, and <code ng-non-bindable="">andBe</code> which let you use multiple comparisons on the same object (chaining must be turned on). Most of these simply allow chaining with natural language. However, <code ng-non-bindable="">deep</code> and <code ng-non-bindable="">deeply</code> turn on deep object comparison when using <code ng-non-bindable="">equal</code> (below), <code ng-non-bindable="">not</code> and <code ng-non-bindable="">Not</code> negate the comparison, and <code ng-non-bindable="">caseless</code> and <code ng-non-bindable="">noCase</code> turn on case insensitivity (for <code ng-non-bindable="">equal</code>, <code ng-non-bindable="">contains</code>, <code ng-non-bindable="">key</code>, <code ng-non-bindable="">keys</code>, <code ng-non-bindable="">value</code>, and <code ng-non-bindable="">values</code>).</p>
<h4 id="equals">Equals</h4>
<p>Compares objects using <code ng-non-bindable="">_.isEqual</code> when <code ng-non-bindable="">deep</code> is applied and using <code ng-non-bindable="">===</code> when it&apos;s not.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(1).equals(1))
if (indeed({foo: { bar: &apos;baz&apos;}}).deeply.equals({foo: { bar: &apos;baz&apos;}})</code></pre>
<p>Aliases: <code ng-non-bindable="">equal</code>, <code ng-non-bindable="">eql</code></p>
<h4 id="matches">Matches</h4>
<p>Checks whether a string matches the given regular expression. If given a string, it will convert it to a RegExp object.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(&apos;foobar&apos;).matches(/oba/)) // or .matches(&apos;oba&apos;)</code></pre>
<p>Aliases: <code ng-non-bindable="">match</code></p>
<h4 id="a">A</h4>
<p>For type comparisons. This is more strict that <code ng-non-bindable="">typeof</code> however. It checks for constructor.name (allowing custom types) and, failing that, uses typeof. It is worth noting that both the type and comparison are lower cased, so &apos;string&apos;, &apos;String&apos;, &apos;strIng&apos;, etc. are all equivalent.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(&apos;hello&apos;).is.a(&apos;string&apos;))</code></pre>
<h4 id="an">An</h4>
<p>Just like isA but preferable (for me anyway) for types beginning with vowels.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed([1, 2, 3]).is.an(&apos;array&apos;))</code></pre>
<h4 id="contains">Contains</h4>
<p>Indicates if the string or array contains the given value.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(&apos;foo bar&apos;).contains(&apos;foo&apos;))
if (indeed([1,2,3]).contains(1))</code></pre>
<p>Aliases: <code ng-non-bindable="">contain</code>, <code ng-non-bindable="">indexOf</code></p>
<h4 id="key">Key</h4>
<p>Indicates if the object (or array, though somewhat by accident) contains the given key.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed({foo: &apos;bar&apos;}).has.key(&apos;foo&apos;))</code></pre>
<p>Aliases: <code ng-non-bindable="">containsKey</code>, <code ng-non-bindable="">containKey</code>, <code ng-non-bindable="">property</code></p>
<h4 id="keys">Keys</h4>
<p>Like <code ng-non-bindable="">.key</code> but for multiple keys. Keys can be passed as an array or multiple strings.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed({foo: &apos;bar&apos;, baz: &apos;quux&apos;}).keys(&apos;foo&apos;, &apos;baz&apos;)
if (indeed({foo: &apos;bar&apos;, baz: &apos;quux&apos;}).keys([&apos;foo&apos;, &apos;baz&apos;]))</code></pre>
<p>Aliases: <code ng-non-bindable="">containKeys</code>, <code ng-non-bindable="">keys</code>, <code ng-non-bindable="">properties</code></p>
<h4 id="value">Value</h4>
<p>Indicates if the object (or array) contains the given value.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed({foo: &apos;bar&apos;}).has.value(&apos;bar&apos;))</code></pre>
<p>Aliases: <code ng-non-bindable="">containsValue</code>, <code ng-non-bindable="">containValue</code></p>
<h4 id="values">Values</h4>
<p>Like <code ng-non-bindable="">.value</code> but for multiple values. Values can be passed as an array or multiple strings.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed({foo: &apos;bar&apos;, baz: &apos;quux&apos;}).has.values(&apos;bar&apos;, &apos;quux&apos;))
if (indeed({foo: &apos;bar&apos;, baz: &apos;quux&apos;}).has.values([&apos;bar&apos;, &apos;quux&apos;]))</code></pre>
<p>Aliases: <code ng-non-bindable="">containsValues</code>, <code ng-non-bindable="">containValues</code></p>
<h4 id="defined">Defined</h4>
<p>Returns true for everthing except undefined. A little cleaner looking than <code ng-non-bindable="">if (typeof thing !== &apos;undefined&apos;)</code>, though that&apos;s exactly what it does under the hood.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(&apos;string&apos;).is.defined())
if (indeed(undefined).is.not.defined())</code></pre>
<h4 id="null">Null</h4>
<p>Returns true for null and false for everything else.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(null).is.null())
if (indeed(&apos;string&apos;).is.not.null())</code></pre>
<h4 id="true">True</h4>
<p>Not to be confused with truthiness, this checks for the literal value <code ng-non-bindable="">true</code>.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(true).is.true())</code></pre>
<h4 id="false">False</h4>
<p>Checks for the literal value <code ng-non-bindable="">false</code>.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(false).is.false())</code></pre>
<h4 id="truthy">Truthy</h4>
<p>Checks for truthiness.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(1).is.truthy())</code></pre>
<h4 id="falsy">Falsy</h4>
<p>Checks for falsiness.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(0).is.falsy())</code></pre>
<h4 id="greaterthan">GreaterThan</h4>
<p>Compares two numbers</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(1).is.greaterThan(0))</code></pre>
<p>Aliases: <code ng-non-bindable="">gt</code>, <code ng-non-bindable="">above</code></p>
<h4 id="lessthan">LessThan</h4>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(1).is.lessThan(2))</code></pre>
<p>Aliases: <code ng-non-bindable="">lt</code>, <code ng-non-bindable="">below</code></p>
<h4 id="greaterthanorequalto">GreaterThanOrEqualTo</h4>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(1).is.greaterThanOrEqualTo(1))</code></pre>
<p>Aliases: <code ng-non-bindable="">gte</code></p>
<h4 id="lessthanorequalto">LessThanOrEqualTo</h4>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(1).is.lessThanOrEqualTo(1))</code></pre>
<p>Aliases: <code ng-non-bindable="">lte</code></p>
<h2 id="mixin">Mixin</h2>
<p>Additionally, <code ng-non-bindable="">indeed</code> has a mixin method for extending these comparison methods. It takes an object of function names with corresponding functions.</p>
<pre><code class="lang-javascript" ng-non-bindable="">indeed.mixin({
  can: function(condition) {
    return function(val) {
      return typeof val[condition] === &apos;function&apos;;
    }
  },
  beginsWith: function(condition) {
    return function(val) {
      return val.charAt(0).toLowerCase() === condition.toLowerCase();
    }
  }
});</code></pre>
<p>The custom functions should be in this form, where <code ng-non-bindable="">condition</code> is the thing to match against and <code ng-non-bindable="">val</code> is the original object (which seems a little backwards, since val is &quot;inside&quot;). These methods, for example, would be called like this:</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed({ foo: function() {} }).can(&apos;foo&apos;).test())
if (indeed(&apos;hello&apos;).beginsWith(&apos;h&apos;).test())</code></pre>
<h4 id="tap">Tap</h4>
<p>Executes a provided function, passing it <code ng-non-bindable="">this</code>.</p>
<pre><code class="lang-javascript" ng-non-bindable="">if (indeed(a).and(b).tap(console.log).or(c))</code></pre>
<h2 id="as-an-assertion-library">As an Assertion Library</h2>
<p>I didn&apos;t write <code ng-non-bindable="">indeed</code> to be an assertion library, but when I discovered that most assertion libraries don&apos;t return true/false values from their assertion methods, thereby making them unusable with mocha-given (which I use), I realized that <code ng-non-bindable="">indeed</code> already had everything it needed (under the hood) to be that kind of assertion library. It just needed a few semantic changes to make it <em>sound</em> like an assertion library.</p>
<h4 id="expect">Expect</h4>
<p><code ng-non-bindable="">expect</code> is an alias to <code ng-non-bindable="">indeed</code>. It does all the same stuff but sounds more test-ish.</p>
<pre><code class="lang-coffee" ng-non-bindable="">Given -&gt; @thing = &apos;foo&apos;
When -&gt; @subject.doSomethingNeat(@thing)
Then -&gt; expect(@thing).to.equal(&apos;foo bar&apos;)</code></pre>
<h4 id="assert">Assert</h4>
<p><code ng-non-bindable="">assert</code> is an alias to <code ng-non-bindable="">eval</code>, <code ng-non-bindable="">val</code>, and <code ng-non-bindable="">test</code>. Once again, it&apos;s only purpose is to convey testing semantics. This only needs to be called when chaining multiple conditions.</p>
<pre><code class="lang-coffee" ng-non-bindable="">Then -&gt; expect.chain(&apos;foo&apos;).to.be.a(&apos;string&apos;).and.to.match(/o$/).and([&apos;bar&apos;]).to.contain(&apos;bar&apos;).assert()</code></pre>
<h4 id="throw">Throw</h4>
<p>Returns true if the passed function throws an error. An optional string, regex, error, or function can be passed for more refined assertions:</p>
<pre><code class="lang-javascript" ng-non-bindable="">expect(fn).to.throw();
expect(fn).to.throw(&apos;Inconceivable!&apos;);
expect(fn).to.throw(new Error(&apos;Mischief is afoot&apos;));
expect(fn).to.throw(/timeout/);
expect(fn).to.throw(function(e) {
  return ~e.message.indexOf(&apos;!&apos;);
});</code></pre>
<p>Aliases: <code ng-non-bindable="">throws</code></p>
<h4 id="with">With</h4>
<p>Assign parameters to pass to the invocation of a method to assert with throw:</p>
<pre><code class="lang-javascript" ng-non-bindable="">expect(fn).with(&apos;foo&apos;, &apos;bar&apos;).to.throw(&apos;FOO BAR&apos;); // Passes &apos;foo&apos; and &apos;bar&apos; to fn when it&apos;s called</code></pre>
<h4 id="spies">Spies</h4>
<p><code ng-non-bindable="">expect</code> also checks it&apos;s parameter to see if it&apos;s a sinon spy or stub, and if it is, it extends itself with the spy, letting you call sinon methods (which are sometimes awkward) in more natural English. For example:</p>
<pre><code class="lang-javascript" ng-non-bindable="">var spy = sinon.spy()
// ... test things with the spy
expect(spy).to.have.been.called // Doesn&apos;t this feel more natural than &apos;spy.called&apos;</code></pre>
<h4 id="when-to-use-indeed-for-asserting">When to use indeed for asserting</h4>
<p>Indeed will work well with <a href="https://github.com/rendro/mocha-given">mocha-given</a> or <a href="https://github.com/searls/jasmine-given">jasmine-given</a>, but it isn&apos;t a <em>full</em> assertion library to be used in every project since it doesn&apos;t throw AssertionErrors or accept or generate messages (at least for now - perhaps in the next version I will get more abmitious). But because <code ng-non-bindable="">Then -&gt; true</code> is a passing test in Given style testing, it works well in that limited capacity.</p>

        </div>
      </div>
    </div>
  </div>
{%= endblock %}
