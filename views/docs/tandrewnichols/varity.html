{%= extends 'layout.html' %}

{%= block content %}
  <div class="row">
    <div class="col-xs-12">
      <div class="row">
        <div class="mlm plm col-xs-2">
          <div class="list-group fixed-sidebar-top" data-spy="affix" data-offset-top="1">
            <a id="github-{{= module.name }}" ng-init="mixpanel.track_links('#github-{{= module.name }}', 'Click', { target: 'github', module: '{{= module.name }}', action: 'view' })" href="https://github.com/{{= author }}/{{= module.name }}" target="_blank" class="list-group-item"><span class="fa fa-github"></span><span class="mls">View it on Github</span></a>
            <a id="fork-{{= module.name }}" ng-init="mixpanel.track_links('#fork-{{= module.name }}', 'Click', { target: 'github', module: '{{= module.name }}', action: 'fork' })" href="https://github.com/{{= author }}/{{= module.name }}/fork" target="_blank" class="list-group-item"><span class="fa fa-code-fork"></span><span class="mls">Fork it</span></a>
            <a id="npm-{{= module.name }}" ng-init="mixpanel.track_links('#npm-{{= module.name }}', 'Click', { target: 'npm', module: '{{= module.name }}', action: 'view' })" href="https://www.npmjs.org/package/{{= module.name }}" target="_blank" class="list-group-item"><span class="ta ta-npm"></span><span class="mls">View it on npm</span></a>
            <a href="http://twitter.com/share" tweet='Check out "{{= module.name }}" at' tweet-tags="nodejs" tweet-topic="{{= module.name }}" class="list-group-item"><span class="fa fa-twitter"></span><span class="mls">Tweet it</span></a>
            {%= if module.coverage %}
              <a href="/coverage/{{= module.name }}" ng-init="mixpanel.track_links('#btn-coverage-{{= module.name }}', 'Click', { target: 'coverage', module: '{{= module.name }}', action: 'view' })" class="list-group-item"><span class="fa fa-code"></span><span class="mls">View test coverage</span></a>
            {%= endif %}
          </div>
          <div class="list-group text-center fixed-sidebar" data-spy="affix" data-offset-top="1" style="font-size: 20pt;">
            <a id="btn-github-{{= module.name }}" ng-init="mixpanel.track_links('#btn-github-{{= module.name }}', 'Click', { target: 'github', page: '{{= module.name }}' })" href="https://github.com/{{= author }}/{{= module.name }}" target="_blank" class="list-group-item" title="View it on Github"><span class="fa fa-github"></span></a>
            <a id="btn-fork-{{= module.name }}" ng-init="mixpanel.track_links('#btn-fork-{{= module.name }}', 'Click', { target: 'github', page: 'fork {{= module.name }}' })" href="https://github.com/{{= author }}/{{= module.name }}/fork" target="_blank" class="list-group-item" title="Fork it"><span class="fa fa-code-fork"></span></a>
            <a id="btn-npm-{{= module.name }}" ng-init="mixpanel.track_links('#btn-npm-{{= module.name }}', 'Click', { target: 'npm', page: '{{= module.name }}' })" href="https://www.npmjs.org/package/{{= module.name }}" target="_blank" class="list-group-item" title="View it on npm"><span class="ta ta-npm"></span></a>
            <a href="http://twitter.com/share" tweet='Check out "{{= module.name }}" at' tweet-tags="nodejs" tweet-topic="{{= module.name }}" class="list-group-item" title="Tweet it"><span class="fa fa-twitter"></span></a>
            {%= if module.coverage %}
              <a id="btn-coverage-{{= module.name }}" ng-init="mixpanel.track_links('#btn-coverage-{{= module.name }}', 'Click', { target: 'coverage', page: '{{= module.name }}' })" href="/coverage/{{= module.name }}" class="list-group-item" title="View test coverage"><span class="fa fa-code"></span></a>
            {%= endif %}
          </div>
        </div>
        <div class="col-xs-9">
          <p><a href="https://travis-ci.org/tandrewnichols/varity"><img src="https://travis-ci.org/tandrewnichols/varity.png" alt="Build Status"></a> <a href="https://npmjs.org/package/varity"><img src="http://img.shields.io/npm/dm/varity.svg" alt="downloads"></a> <a href="https://npmjs.org/package/varity"><img src="http://img.shields.io/npm/v/varity.svg" alt="npm"></a></p>
<h1 id="varity">Varity</h1>
<p>Javascript arity simplified.</p>
<h2 id="why-">Why?</h2>
<p>The ability to pass a variable number of parameters to functions is a nice feature of javascript, but it can sometimes lead to boilerplate code at the top of a method to determine which parameters you&apos;re actually working with. Something like</p>
<pre><code class="lang-javascript" ng-non-bindable="">function (url, params, options, callback) {
  if (typeof params === &apos;function&apos;) {
    callback = params, params = {}, options = {};
  } else if (typeof options === &apos;function&apos;) {
    callback = options, options = {};
  }
  // . . . now for actual function logic
}</code></pre>
<p>Varity (&quot;variable-arity&quot;) handles this for you. And it can do some other handy things to.</p>
<h2 id="install">Install</h2>
<p><code ng-non-bindable="">npm install varity --save</code></p>
<h2 id="basic-use">Basic Use</h2>
<p>When you <code ng-non-bindable="">require(&apos;varity&apos;)</code>, you&apos;ll get a wrapper function back. This wrapper accepts a set of expectations and the function to wrap, then handles boilerplate arity shenanigans for you. If you tell varity you&apos;re expecting a string and a number, but only pass it a number, varity will fill in the string argument with <code ng-non-bindable="">undefined</code>. No need to test <code ng-non-bindable="">if (typeof options === &apos;function&apos;)</code>. There are several ways to tell varity what you&apos;re expecting.</p>
<h3 id="with-types">With types</h3>
<pre><code class="lang-javascript" ng-non-bindable="">var $ = require(&apos;varity&apos;);
var wrapped = $(Array, Function, function(list, callback) {
  // list is guaranteed to be an array or undefined
  // callback will always be a function or undefined
});

// For example
wrapped([1, 2, 3]); // the function will be called with [1, 2, 3] and undefined

// or
wrapped(function() {}); // undefined, function() {}

// any additional params will also be passed on
wrapped([1, 2, 3], function() {}, { foo: &apos;bar&apos; }) // [1, 2, 3], function() {}, { foo: &apos;bar&apos; }

// in fact, varity is smart enough to handle this:
wrapped([1, 2, 3], { foo: &apos;bar&apos; }) // [1, 2, 3], undefined, { foo: &apos;bar&apos; }

// and even
wrapped({ foo: &apos;bar&apos;}) // undefined, undefined, { foo: &apos;bar&apos;}</code></pre>
<p>You can pass any object type (use <code ng-non-bindable="">null</code> for Null and <code ng-non-bindable="">undefined</code> for Undefined - though there&apos;s not much value in expecting these in functions). You can also pass custom types.</p>
<pre><code class="lang-javascript" ng-non-bindable="">function Foo () {}
var wrapped = $(Foo, function(foo) {
  // We have a foo!
});</code></pre>
<h3 id="with-an-array">With an array</h3>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $([&apos;String&apos;, &apos;Function&apos;], function(name, callback) {
  // . . .
});</code></pre>
<p>This let&apos;s you compile argument lists on the fly if necessary.</p>
<pre><code class="lang-javascript" ng-non-bindable="">var args = [&apos;String&apos;];
if (opts.async) {
  args.push(&apos;Function&apos;);
}

var wrapped = $.apply($, [args, function(path, cb){
  // Do neat stuff
}]);</code></pre>
<h3 id="with-a-string">With a string</h3>
<p>The first two methods are useful, but also lengthy. The real value in varity is in string abbreviations. To keep calls to varity short, all built in types have one character analogs that can be passed collectively as a single string:</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;ssf&apos;, function(fname, lname, callback) {
  // . . . 
});</code></pre>
<p>The following abbreviations are currently recognized by varity:</p>
<ul>
<li>s: String</li>
<li>f: Function</li>
<li>o: Object</li>
<li>a: Array</li>
<li>1: Number</li>
<li>b: Boolean</li>
<li>r: RegExp</li>
<li>d: Date</li>
<li>N: NaN</li>
<li>n: Null</li>
<li>u: Undefined</li>
<li>A: Arguments</li>
<li>i: Infinity</li>
<li>e: Error</li>
<li>E: Element</li>
<li>$: jQuery</li>
</ul>
<p>Additionally, strings can have array wrappers (<code ng-non-bindable="">[s]</code>) and ors (<code ng-non-bindable="">|</code>). Any letter wrapped in <code ng-non-bindable="">[]</code> tells varity to wrap the arg (if it matches that type) in an array. <code ng-non-bindable="">|</code> says that either of two types are acceptable. These can also be combined.</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;[s]&apos;, function(list) {
  // When called with a string, arguments will be an array with that string as the first and only item
});

var wrapped = $(&apos;1|b&apos;, function(isTruthy) {
  // Either a number or boolean can be passed
});

var wrapped = $(&apos;[s]|a&apos;, function(list) {
  // Either a string (which will be wrapped) or an array can be passed
});

var wrapped = $(&apos;[s]|[1]&apos;, function(list) {
  // Either a string or number can be passed, but in either case, it will be wrapped as an array
});</code></pre>
<h2 id="flags">Flags</h2>
<p>Knowing that <code ng-non-bindable="">options</code> will never be a function is nice, but you might still need to check for definedness before doing something with a parameter:</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;af&apos;, function(list, cb) {
  cb(list.concat([&apos;foo&apos;, &apos;bar&apos;]);
});

wrapped(function(newList) { /* . . . */ }); // Uh, oh. Cannot call method concat of undefined.</code></pre>
<p>Thus, varity has some flags, indicated with symbols, that tell it to handle awkward conditions, such as the above, gracefully.</p>
<h3 id="populate-">Populate: +</h3>
<p>Tells varity to return a default of the given type so that you don&apos;t have to worry about calling type specific methods.</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;+a&apos;, function(list) {
  list.push(&apos;something&apos;); // list will ALWAYS be an array
}</code></pre>
<p>The built in defaults are as follows (though you can override them - more on that later).</p>
<ul>
<li>String</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">&apos;&apos;</code></pre>
<ul>
<li>Function</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">function(){}</code></pre>
<ul>
<li>Object</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">{}</code></pre>
<ul>
<li>Array</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">[]</code></pre>
<ul>
<li>Number</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">0</code></pre>
<ul>
<li>Boolean</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">false</code></pre>
<ul>
<li>RegExp</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">/.*/</code></pre>
<ul>
<li>Date</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">(function() {
  return new Date();
})()</code></pre>
<ul>
<li>NaN</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">NaN</code></pre>
<ul>
<li>Null</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">null</code></pre>
<ul>
<li>Undefined</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">undefined</code></pre>
<ul>
<li>Arguments: </li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">(function(){
  return arguments;
})(undefined)</code></pre>
<ul>
<li>Infinity</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">2/0 // because I like the number 2</code></pre>
<ul>
<li>Error: </li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">(function() {
  return new Error();
})()</code></pre>
<ul>
<li>Element:</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">(function() {
  if (typeof window !== &apos;undefined&apos;) {
    return window.document;
  } else {
    return &apos;&lt;div&gt;&lt;/div&gt;&apos;;
  }
})()</code></pre>
<ul>
<li>jQuery:</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">(function() {
  if (typeof $ !== &apos;undefined&apos;) {
    return $(document);
  } else {
    return [];
  }
})()</code></pre>
<h3 id="optional-">Optional: -</h3>
<p>Normally, if you pass two of the same type next to each other, Varity will assign the first parameter that matches that type to the first argument and leave the second undefined.</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;oo&apos;, function(options, data) {
  // If only one object is passed, it will be passed as &quot;options&quot; and &quot;data&quot; will be undefined
});</code></pre>
<p>The <code ng-non-bindable="">optional</code> flag reverses this behavior. (Alternatively, you could just reverse the parameters: <code ng-non-bindable="">function(data, options)</code>.)</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;-oo&apos;, function(options, data) {
  // Now if only one object is passed, it&apos;ll be set to &quot;data&quot;, leaving &quot;options&quot; undefined.
});</code></pre>
<p>You can also combine <code ng-non-bindable="">populate</code> with <code ng-non-bindable="">optional</code>:</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;-+oo&apos;, function(obj1, obj2) {
  // If passed only {foo: &apos;bar&apos;}, arguments will be {}, {foo: &apos;bar&apos;}
});</code></pre>
<h3 id="non-empty-_">Non-empty: _</h3>
<p>The non-empty flag tells varity to treat &quot;empty&quot; parameters as if they were undefined. This isn&apos;t that useful unless you change the defaults (more below). If you tell varity to populate a type with some other default and use the _ flag, varity will replace an empty type (e.g. <code ng-non-bindable="">{}</code>, <code ng-non-bindable="">[]</code>, <code ng-non-bindable="">function() {}</code>, etc.) with the default of that type.</p>
<pre><code class="lang-javascript" ng-non-bindable="">$.populate(&apos;Object&apos;, {
  dataType: &apos;json&apos;,
  method: &apos;put&apos;
});

var wrapped = $(&apos;s_o&apos;, function(url, opts) {
  // see below for more about populate
});
wrapped(&apos;something.com&apos;, {}); // Provides &apos;something.com&apos; and { dataType: &apos;json&apos;, method: &apos;put&apos; }</code></pre>
<h3 id="required-">Required: *</h3>
<p>Marks a parameter as required. If that parameter is not passed, Varity will throw an exception.</p>
<pre><code class="lang-javascript" ng-non-bindable="">var wrapped = $(&apos;*so&apos;, function(name, options) {
  // . . .
});
wrapped({ async: true }); // throws</code></pre>
<h3 id="extend-">Extend: &amp;</h3>
<p>For matching types, the actual argument will be extended with additional defaults. For objects, this means a deep object extend; for arrays, concat; for strings, joining with &quot; &quot;; and for functions, calling <code ng-non-bindable="">_.compose</code> (with the default function coming first in the composition). This is an excellent way to handle option extension.</p>
<pre><code class="lang-javascript" ng-non-bindable="">$.extend(&apos;Object&apos;, { async: true }); // See &quot;Helpers&quot; below
var wrapped = $(&apos;&amp;o&apos;, function(options) { });
wrapped({ path: &apos;/foo/bar&apos; }); // options will equal { async: true, path: &apos;/foo/bar&apos; }

$.extend(&apos;Array&apos;, [ &apos;Chuck&apos; ]);
var wrapped = $(&apos;&amp;a&apos;, function(ppl) { });
wrapped([ &apos;Sue&apos;, &apos;Douglas&apos; ]); // ppl will equal [ &apos;Sue&apos;, &apos;Douglas&apos;, &apos;Chuck&apos; ]

$.extend(&apos;String&apos;, &apos;Please try again.&apos;);
var wrapped = $(&apos;&amp;s&apos;, function(message) { });
wrapped(&apos;We were unable to update your profile.&apos;); // message will equal &apos;We were unable to update your profile. Please try again.&apos;

$.extend(&apos;Function&apos;, function(name) { return &apos;My name is &apos; + name; });
var wrapped = $(&apos;&amp;f&apos;, function(fn) { });
wrapped(function(message) { console.log(message); }); // when &quot;fn&quot; is called with &quot;Tim&quot;, &quot;My name is Tim&quot; will be logged</code></pre>
<h2 id="helpers">Helpers</h2>
<p>Varity also a couple helper methods for changing options.</p>
<h3 id="varity-configure">varity.configure</h3>
<p>Use <code ng-non-bindable="">varity.configure</code> for one time, initial setup. All calls to <code ng-non-bindable="">varity()</code> after that will use whatever options you pass. You can pass the following options to <code ng-non-bindable="">varity.configure</code>:</p>
<ul>
<li>letters - add custom abbreviations or override default ones</li>
<li>symbols - additional symbols and their corresponding functions</li>
<li>defaults - override built in defaults or provide defaults for custom types</li>
<li>populate - turn on <code ng-non-bindable="">populate</code> for all types (with <code ng-non-bindable="">true</code>) or a set of types (with an array) so that you don&apos;t have to use the <code ng-non-bindable="">+</code> flag</li>
</ul>
<pre><code class="lang-javascript" ng-non-bindable="">var $ = require(&apos;varity&apos;);
$.configure({
  letters: {
    &apos;~&apos;: &apos;Foo&apos;,
    &apos;a&apos;: &apos;Array&apos;,
    &apos;g&apos;: &apos;Arguments&apos; // If you don&apos;t like dealing with captials 
  },
  symbols: {
    &apos;!&apos;: function(arg, context) {
      return !!arg;
    }
  },
  defaults: {
    &apos;Object&apos;: {
      jsonp: true,
      method: &apos;get&apos;,
      data: {
        user: localStorage.get(&apos;user&apos;)
      }
    },
    &apos;Foo&apos;: function() {
      return new Foo(&apos;my foo param&apos;);
    }
  },
  populate: true // Always populate ALL types

  /*
   * OR
   *
   * populate: [&apos;Object&apos;, &apos;Array&apos;, &apos;Foo&apos;]
   *
   * to always populate ONLY these types
   */
});</code></pre>
<p>Note that these options will be used for EVERY call to varity. If you need to undo these options, you can call <code ng-non-bindable="">varity.reset()</code>, which will restore the defaults. However, any already wrapped functions will still have the custom options.</p>
<p>There are also simplified helpers that set one-time options:</p>
<h3 id="varity-letters">varity.letters</h3>
<pre><code class="lang-javascript" ng-non-bindable="">$.letters(&apos;q&apos;, &apos;Quux&apos;);</code></pre>
<h3 id="varity-symbols">varity.symbols</h3>
<pre><code class="lang-javascript" ng-non-bindable="">$.symbols(&apos;!&apos;, function(arg, context) {
  return !!arg;
});</code></pre>
<h3 id="varity-defaults">varity.defaults</h3>
<pre><code class="lang-javascript" ng-non-bindable="">$.defaults(&apos;Array&apos;, [1, 2, 3]);</code></pre>
<h3 id="varity-populate">varity.populate</h3>
<pre><code class="lang-javascript" ng-non-bindable="">$.populate(&apos;Array&apos;, [1, 2, 3]);

// or

$.populate(&apos;Array&apos;);

// or

$.populate(true);</code></pre>
<p>Unlike the others, which simply set the corresponding option, varity.populate both adds the type to the <code ng-non-bindable="">populate</code> list <em>and</em> calls $.defaults when called with two arguments (since, for a one-time option, it&apos;s essentially implied that the populating thing should be used). When called with only a type, that type is added to the <code ng-non-bindable="">populate</code> list, but no additional default is set. When called with <code ng-non-bindable="">true</code>, all types will be populated by default.</p>
<h3 id="varity-extend">varity.extend</h3>
<pre><code class="lang-javascript" ng-non-bindable="">$.extend(&apos;Object&apos;, { async: true, path: &apos;/foo/bar&apos; });</code></pre>
<h2 id="custom-symbols">Custom Symbols</h2>
<p>Each symbol corresponds to a function that receives the current argument and a context. The context looks like this:</p>
<pre><code class="lang-javascript" ng-non-bindable="">{
  symbols: [&apos;-&apos;, &apos;+&apos;], // a list of symbols passed with this argument
  types: [&apos;String&apos;], // a list of types to match against
  wrapType: &apos;array&apos; // indicates whether [] or | were used in the string
}</code></pre>
<p>In addition, the varity object is passed as the <code ng-non-bindable="">this</code> context, so you can access things like <code ng-non-bindable="">this.args</code>, which has the full set of arguments passed to varity. You can create custom functionality by adding symbols and manipulating one or both of these parameters. Use this to whatever destructive ends you see fit. Note that symbol operations are called in the order in which they&apos;re passed, which <em>can</em> make a difference. For instance, if you want to use <code ng-non-bindable="">+</code> and <code ng-non-bindable="">-</code> together, you should always pass <code ng-non-bindable="">-</code> first, since, after <code ng-non-bindable="">+</code> runs, the current argument will <em>never</em> be undefined (well, unless the expected type is <code ng-non-bindable="">undefined</code>). The example in the <code ng-non-bindable="">configure</code> section above coerces results to booleans. You can take a look at the existing symbol operations to get an idea of how to use the context object.</p>

        </div>
      </div>
    </div>
  </div>
{%= endblock %}
